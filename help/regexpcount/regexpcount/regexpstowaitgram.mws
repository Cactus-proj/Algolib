{VERSION 4 0 "IBM INTEL LINUX22" "4.0" }
{USTYLETAB {CSTYLE "Maple Input" -1 0 "Courier" 0 1 255 0 0 1 0 1 0 0 
1 0 0 0 0 1 }{CSTYLE "2D Math" -1 2 "Times" 0 1 0 0 0 0 0 0 2 0 0 0 0 
0 0 1 }{CSTYLE "Hyperlink" -1 17 "" 0 1 0 128 128 1 2 0 1 0 0 0 0 0 0 
1 }{CSTYLE "2D Output" 2 20 "" 0 1 0 0 255 1 0 0 0 0 0 0 0 0 0 1 }
{CSTYLE "Help Normal" -1 30 "Times" 1 12 0 0 0 0 0 0 0 0 0 0 0 0 0 1 }
{CSTYLE "" -1 256 "" 0 1 0 0 0 0 0 1 0 0 0 0 0 0 0 1 }{PSTYLE "Normal
" -1 0 1 {CSTYLE "" -1 -1 "" 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 }0 0 0 
-1 -1 -1 0 0 0 0 0 0 -1 0 }{PSTYLE "Heading 1" 0 3 1 {CSTYLE "" -1 -1 
"" 1 18 0 0 0 0 0 1 0 0 0 0 0 0 0 1 }1 0 0 0 8 4 0 0 0 0 0 0 -1 0 }
{PSTYLE "Heading 2" 3 4 1 {CSTYLE "" -1 -1 "" 1 14 0 0 0 0 0 0 0 0 0 
0 0 0 0 1 }0 0 0 -1 8 2 0 0 0 0 0 0 -1 0 }{PSTYLE "Maple Output" 0 11 
1 {CSTYLE "" -1 -1 "" 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 }3 3 0 -1 -1 -1 
0 0 0 0 0 0 -1 0 }{PSTYLE "" 11 12 1 {CSTYLE "" -1 -1 "" 0 1 0 0 0 0 
0 0 0 0 0 0 0 0 0 1 }1 0 0 -1 -1 -1 0 0 0 0 0 0 -1 0 }{PSTYLE "Bullet \+
Item" 0 15 1 {CSTYLE "" -1 -1 "" 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 }0 0 
0 -1 3 3 0 0 0 0 0 0 15 2 }}
{SECT 0 {EXCHG {PARA 3 "" 0 "" {TEXT -1 30 "regexpcount[regexpstowaitg
ram]" }{TEXT 30 110 " - transform a grammar defining regular expressio
ns to a marked grammar automaton for waiting time until match" }}
{PARA 4 "" 0 "usage" {TEXT -1 17 "Calling Sequence:" }}{PARA 0 "" 0 "
" {TEXT -1 49 "     regexpstowaitgram(spec, ['Epsilon'],regexp2)" }}
{PARA 0 "" 0 "" {TEXT -1 62 "     regexpstowaitgram(spec,  regexp1, re
gexp2, letter, flag) " }}{PARA 4 "" 0 "" {TEXT -1 11 "Parameters:" }}
{PARA 0 "" 0 "" {TEXT -1 5 "     " }{TEXT -1 23 "spec                 \+
- " }{TEXT -1 68 "a combinatorial specification for one or several reg
ular expressions" }}{PARA 0 "" 0 "" {TEXT -1 12 "     regexp1" }{TEXT 
-1 67 "          - a list [name, 'error'[k, errs]], which may be repla
ced " }{TEXT -1 16 "by ['Epsilon']; " }}{PARA 0 "" 0 "" {TEXT -1 171 "
                                   the parameter 'error'[] is optional
, k is the number of errors allowed and errs is a subset of  the set o
f errors \{'subst','ins','del'\}," }}{PARA 0 "" 0 "" {TEXT -1 92 "    \+
                               for substitutions, insertions and delet
ions respectively." }}{PARA 0 "" 0 "" {TEXT -1 94 "     regexp2       \+
  -   same as regexp1 except that regexp2 cannot be replaced by ['Epsi
lon']" }}{PARA 0 "" 0 "" {TEXT -1 117 "     letter               -  le
tter for marking the waiting transitions after match with the start re
gular expression" }}{PARA 0 "" 0 "" {TEXT -1 118 "     flag           \+
       -  'rematch': matches with the start regular expression are all
owed during the waiting time" }}{PARA 0 "" 0 "" {TEXT -1 125 "        \+
                           'norematch': no match with the start regula
r expression is allowed during the waiting time" }}{PARA 0 "" 0 "" 
{TEXT -1 4 "    " }}{PARA 0 "" 0 "" {TEXT -1 3 "   " }}}{SECT 0 {PARA 
4 "" 0 "info" {TEXT -1 12 "Description:" }}{PARA 15 "" 0 "" {TEXT -1 
220 "If regexp1=['Epsilon'], this function returns the grammar for an \+
automaton which recognizes texts ending with a match with the regular \+
expression specified by regexp2 and with no other match with this regu
lar expression." }}{PARA 15 "" 0 "" {TEXT -1 497 "otherwise, this func
tion returns a grammar for a marked automaton which recognizes texts t
hat begin with a match with the start regular expression, finishes wit
h a match with the regular expression specified by regexp2, do not hav
e other match with this latter regular expression, and where a mark is
 added after each letter of the text following the match with the star
t regular expression (waiting time). These marked letters in the text \+
correspond to marked transitions in the output automaton." }}{PARA 15 
"" 0 "" {TEXT -1 4 "See " }{HYPERLNK 17 "regexpcount[specification]" 
2 "regexpcount[specification]" "" }{TEXT -1 76 " for complete specific
ations of the output automaton specified as a grammar." }}{PARA 15 "" 
0 "" {TEXT -1 2 "A " }{TEXT 256 17 "marked transition" }{TEXT -1 169 "
 is of the form Prod(l,m,s), where l belongs to the alphabet, m is a m
ark, and s is a state. In the grammar of the output automaton, the mar
k is associated with Epsilon." }}{PARA 15 "" 0 "" {TEXT -1 45 " When t
he output automaton is processed with " }{HYPERLNK 17 "combstruct[gfso
lve]" 2 "combstruct[gfsolve]" "" }{TEXT -1 10 ". or with " }{HYPERLNK 
17 "combstruct[gfeqns]" 2 "combstruct[gfeqns]" "" }{TEXT -1 5 " and " 
}{HYPERLNK 17 "solve/linear" 2 "solve,linear" "" }{TEXT -1 72 ", the r
esulting multivariate generating function gives the waiting time." }}
{PARA 15 "" 0 "" {TEXT -1 491 "WARNING: when you want to compute the w
aiting time for the second regular expression, assuming a match with t
he start regular expression, you must divide the waiting probability g
enerating function by the value of the (eventually weighted or Markov)
 generating function of the language of the start regular expression a
t z=1 (probability that a text starts with a match with this regular e
xpression).  Moreover, in the norematch case, the resulting probabilit
y distribution may be defective." }}}{SECT 0 {PARA 4 "" 0 "examples" 
{TEXT -1 9 "Examples:" }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 18 "wit
h(regexpcount):" }}}{PARA 0 "" 0 "" {TEXT -1 66 "R[1]=ab. Compute the \+
waiting time for the first occurrence of R[1]" }}{EXCHG {PARA 0 "> " 
0 "" {MPLTEXT 1 0 95 "Greg:=\{R[1]=Prod(a,b),R[2]=b,a=Atom,b=Atom\}:\n
WaitG:=regexpstowaitgram(Greg,['Epsilon'],[R[1]]);" }}{PARA 11 "" 1 "
" {XPPMATH 20 "6#>%&WaitGG<'/%\"bG%%AtomG/%\"aGF(/%#w2G%(EpsilonG/%#w3
G-%&UnionG6$-%%ProdG6$F*F/-F46$F'F,/&%\"RG6#\"\"\"-F16$F3-F46$F'F9" }}
}{PARA 0 "" 0 "" {TEXT -1 46 "Compute the corresponding generating fun
ction " }}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 17 "with(combstruct):
" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 42 "subs(gfsolve(WaitG,unla
belled,z),R[1](z));" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#*&*$)%\"zG\"\"#
\"\"\"F(,(F(F(*&F'F(F&F(!\"\"*$F%F(F(F+" }}}{EXCHG {PARA 0 "" 0 "" 
{TEXT -1 73 "Compute the probability generating function in the unifor
m Bernoulli case" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 14 "subs(z=
z/2,%);" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#,$*&*$)%\"zG\"\"#\"\"\"F),(
F)F)F'!\"\"*&#F)\"\"%F)F&F)F)F+F-" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 
43 "Compute the expectation of the waiting time" }}}{EXCHG {PARA 0 "> \+
" 0 "" {MPLTEXT 1 0 20 "subs(z=1,diff(%,z));" }}{PARA 11 "" 1 "" 
{XPPMATH 20 "6#\"\"%" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 127 "Compute \+
the wait automaton for R[1] in the markov case of order 1, when one su
bstitution is allowed (R[1]=ab, pattern=ab+bb+aa)" }}}{EXCHG {PARA 0 "
> " 0 "" {MPLTEXT 1 0 64 "regexpstowaitgram(Greg,['Epsilon'],[R[1],'Er
ror'[1,\{'subst'\}]]):" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 36 "W
aitMarkovG:=grammarkov(%,R[1],1,k);" }}{PARA 12 "" 1 "" {XPPMATH 20 "6
#>%,WaitMarkovGG<-/&%\"kG6$%\"bG%\"aG%%AtomG/&F(6$F*F*F,/&F(6#F+F,/&F(
6#F*F,/&F(6$F+F+F,/&F(6$F+F*F,/&%\"RG6#\"\"\"-%&UnionG6$-%%ProdG6$F1&%
#w2GF2-FE6$F4&%#w3GF5/&%#w4GF2%(EpsilonG/FK-FB6$-FE6$F'FG-FE6$F.&%#w1G
F5/FG-FB6$-FE6$F7FN-FE6$F:FX/FXFP" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 
81 "Wait for R[2]=ba, after a match with R[1]=a+bb, when rematch with \+
R[1] is allowed" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 119 "Greg:=
\{R[1]=Union(a,Prod(b,b)),R[2]=Prod(b,a),a=Atom,b=Atom\}:\nWaitG:=rege
xpstowaitgram(Greg,[R[1]],[R[2]],m,'rematch');" }}{PARA 12 "" 1 "" 
{XPPMATH 20 "6#>%&WaitGG<,/&%\"RG6#\"\"#-%&UnionG6$-%%ProdG6$%\"bG%#w5
G-F/6$%\"aG%#w3G/%\"mG%(EpsilonG/%#w9G-F,6$-F/6%F1F8%$w14G-F/6%F5F8F;/
F6F</F@-F,6$-F/6%F5F8%$w11GF>/F1%%AtomG/F5FK/F2-F/6$F1%#w6G/FIF9/FPFE
" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 73 "Compute the wait generating f
unction (in u) in the uniform Bernoulli case" }}}{EXCHG {PARA 0 "> " 
0 "" {MPLTEXT 1 0 57 "GFM:=subs(gfsolve(WaitG,unlabelled,z,[[u,m]]),R[
2](z,u));" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#>%$GFMG,$*&*()%\"zG\"\"$
\"\"\"%\"uGF+,(!\"\"F+*&F)F+F,F+F+F,F.F+F+,(F+F+*(\"\"#F+F)F+F,F+F.*&)
F)F2F+)F,F2F+F+F.F." }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 24 "Wait
GF:=subs(z=1/2,GFM);" }}{PARA 11 "" 1 "" {XPPMATH 20 "6#>%'WaitGFG,$*&
*&%\"uG\"\"\",&!\"\"F)*&#F)\"\"#F)F(F)F+F)F),(F)F)F(F+*&#F)\"\"%F))F(F
.F)F)F+#F+\"\")" }}}{EXCHG {PARA 0 "" 0 "" {TEXT -1 94 "Compute the pr
obability that a text begins with a match with the start regular expre
ssion R[1]" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 0 69 "StartGF:=subs
(gfsolve(regexptogram(Greg,R[1]),unlabelled,z),R[1](z));" }}{PARA 11 "
" 1 "" {XPPMATH 20 "6#>%(StartGFG,&%\"zG\"\"\"*$)F&\"\"#F'F'" }}}
{EXCHG {PARA 0 "" 0 "" {TEXT -1 16 "Normalize WaitGF" }}}{EXCHG {PARA 
0 "> " 0 "" {MPLTEXT 1 0 35 "WaitGF:=WaitGF/eval(StartGF,z=1/2);" }}
{PARA 11 "" 1 "" {XPPMATH 20 "6#>%'WaitGFG,$*&*&%\"uG\"\"\",&!\"\"F)*&
#F)\"\"#F)F(F)F+F)F),(F)F)F(F+*&#F)\"\"%F))F(F.F)F)F+#F+\"\"'" }}}
{EXCHG {PARA 0 "" 0 "" {TEXT -1 62 "Compute the average time wait for \+
R[2] after a match with R[1]" }}}{EXCHG {PARA 0 "> " 0 "" {MPLTEXT 1 
0 33 "expect:=subs(u=1,diff(WaitGF,u));" }}{PARA 11 "" 1 "" {XPPMATH 
20 "6#>%'expectG#\"#5\"\"$" }}}}{SECT 0 {PARA 4 "" 0 "seealso" {TEXT 
-1 10 "See Also: " }}{PARA 0 "" 0 "" {HYPERLNK 17 "regexpcount" 2 "reg
expcount" "" }{TEXT -1 2 ", " }{HYPERLNK 17 "regexpcount[specification
]" 2 "regexpcount[specification]" "" }{TEXT -1 3 ",  " }{HYPERLNK 17 "
regexpcount[grammarkov]" 2 "regexpcount[grammarkov]" "" }{TEXT -1 2 ",
 " }{HYPERLNK 17 "regexpcount[gramweight]" 2 "regexpcount[gramweight]
" "" }{TEXT -1 2 ", " }{HYPERLNK 17 "regexpcount[regexptomatchesgram]
" 2 "regexpcount[regexptomatchesgram]" "" }{TEXT -1 2 ", " }{HYPERLNK 
17 "combstruct[gfeqns]" 2 "combstruct[gfeqns]" "" }{TEXT -1 3 ",  " }
{HYPERLNK 17 "" 1 "" "" }{HYPERLNK 17 "solve/linear" 2 "solve,linear" 
"" }{TEXT -1 1 " " }}}}{MARK "3 0 0" 0 }{VIEWOPTS 1 1 0 1 1 1803 1 1 
1 1 }{PAGENUMBERS 0 1 2 33 1 1 }
