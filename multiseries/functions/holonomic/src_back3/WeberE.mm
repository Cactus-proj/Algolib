# Copyright (C) 1991--2010 by INRIA.
#
# This file is part of Algolib.
#
# Algolib is free software: you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Algolib is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with Algolib.  If not, see
# <http://www.gnu.org/licenses/>.

`multiseries/function`[`WeberE/infinity/aux/2/-Pi .. Pi`, 0, "BasisVector", 0, "MultiSeries", 0]:=proc (expr, scale, var, order, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:43`; SERIES(scale,`multiseries/function`[`WeberE/infinity/aux/2/-Pi .. Pi`,0,"CoeffProc",0](order,a1),1,algebraic,[`$`(0 .. order)],order+1,integer,eval(scale['variable'],1),`WeberE/infinity/aux/2/-Pi .. Pi/0/BasisVector/0/MultiSeries/0`(a1,eval(scale['variable'],1))) end proc:
`multiseries/function`[`WeberE/infinity/aux/1/-Pi .. Pi`, 0, "BasisVector", 0]:=proc (n, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:39`; [0, `multiseries/function`[`WeberE/infinity/aux/1/-Pi .. Pi`,0,"CoeffProc"](n,0,a1)] end proc:
`multiseries/function`[WeberE, 0, "BasisVector", 0, 0, 0, "MultiSeries"]:=proc (expr, scale, var, order, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:27`; [`multiseries/function`[WeberE,0,"BasisVector",0,0,0,"MultiSeries",0](args), `multiseries/function`[WeberE,0,"BasisVector",0,0,0,"MultiSeries",1](args)] end proc:
`multiseries/function`[`WeberE/infinity/aux/1/-Pi .. Pi`, _AnyFiniteOrdinaryPoint, "CoeffProc"]:=proc (n, arg0, arg1, arg2, arg3, a1, xarg) local i1, loc; option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:37`; if n = 0 then [arg0] elif n = 1 then [arg0, arg1] elif n = 2 then [arg0, arg1, 1/4*arg2] elif n = 3 then [arg0, arg1, 1/4*arg2, 1/36*arg3] elif n = 4 then [arg0, arg1, 1/4*arg2, 1/36*arg3, 1/1152/xarg^6*(-360*I*arg2*xarg^3+12*arg0-9*arg0*xarg^2+36*arg0*a1^2*xarg^2-32*I*arg3*xarg^4-48*arg0*a1^2+192*arg1*xarg+144*arg1*a1^2*xarg^3-12*I*arg0*xarg+96*I*arg1+96*I*arg1*a1^2*xarg^2-396*arg1*xarg^3+48*I*arg0*a1^2*xarg-456*arg2*xarg^4+24*arg2*a1^2*xarg^4+120*arg2*xarg^2-384*I*arg1*xarg^2-72*arg3*xarg^5)] elif n = 5 then [arg0, arg1, 1/4*arg2, 1/36*arg3, 1/1152/xarg^6*(-360*I*arg2*xarg^3+12*arg0-9*arg0*xarg^2+36*arg0*a1^2*xarg^2-32*I*arg3*xarg^4-48*arg0*a1^2+192*arg1*xarg+144*arg1*a1^2*xarg^3-12*I*arg0*xarg+96*I*arg1+96*I*arg1*a1^2*xarg^2-396*arg1*xarg^3+48*I*arg0*a1^2*xarg-456*arg2*xarg^4+24*arg2*a1^2*xarg^4+120*arg2*xarg^2-384*I*arg1*xarg^2-72*arg3*xarg^5), -1/5760/xarg^8*(-912*arg0*a1^2*xarg-384*arg1-192*I*arg0*a1^2-5952*I*arg2*xarg^4-204*I*arg0*xarg^2-336*arg1*a1^2*xarg^2+192*arg2*a1^2*xarg^5+432*I*arg2*xarg^2-6564*I*arg1*xarg^3+1692*arg1*a1^2*xarg^4-8*arg3*a1^2*xarg^6+2208*I*arg1*xarg+48*I*arg0-520*I*arg3*xarg^5+468*arg0*a1^2*xarg^3+228*arg0*xarg+4212*arg1*xarg^2+2904*arg2*xarg^3-4818*arg2*xarg^5-4743*arg1*xarg^4-117*arg0*xarg^3-568*arg3*xarg^6+88*arg3*xarg^4+48*I*arg2*a1^2*xarg^4+816*I*arg0*a1^2*xarg^2+1776*I*arg1*a1^2*xarg^3)] else loc[0] := arg0; loc[1] := arg1; loc[2] := 1/4*arg2; loc[3] := 1/36*arg3; loc[4] := 1/1152/xarg^6*(-360*I*arg2*xarg^3+12*arg0-9*arg0*xarg^2+36*arg0*a1^2*xarg^2-32*I*arg3*xarg^4-48*arg0*a1^2+192*arg1*xarg+144*arg1*a1^2*xarg^3-12*I*arg0*xarg+96*I*arg1+96*I*arg1*a1^2*xarg^2-396*arg1*xarg^3+48*I*arg0*a1^2*xarg-456*arg2*xarg^4+24*arg2*a1^2*xarg^4+120*arg2*xarg^2-384*I*arg1*xarg^2-72*arg3*xarg^5); loc[5] := -1/5760/xarg^8*(-912*arg0*a1^2*xarg-384*arg1-192*I*arg0*a1^2-5952*I*arg2*xarg^4-204*I*arg0*xarg^2-336*arg1*a1^2*xarg^2+192*arg2*a1^2*xarg^5+432*I*arg2*xarg^2-6564*I*arg1*xarg^3+1692*arg1*a1^2*xarg^4-8*arg3*a1^2*xarg^6+2208*I*arg1*xarg+48*I*arg0-520*I*arg3*xarg^5+468*arg0*a1^2*xarg^3+228*arg0*xarg+4212*arg1*xarg^2+2904*arg2*xarg^3-4818*arg2*xarg^5-4743*arg1*xarg^4-117*arg0*xarg^3-568*arg3*xarg^6+88*arg3*xarg^4+48*I*arg2*a1^2*xarg^4+816*I*arg0*a1^2*xarg^2+1776*I*arg1*a1^2*xarg^3); for i1 from 6 to n do loc[i1] := (-(11979-396*a1^2)*loc[i1-6]-(44586*xarg-1224*xarg*a1^2-6876*I+144*I*a1^2)*loc[i1-5]-(42996*xarg^3-14784*I*xarg^2+96*I-624*a1^2*xarg^3-1728*xarg+96*I*a1^2*xarg^2)*loc[i1-3]-(13344*xarg^4-4704*I*xarg^3-96*a1^2*xarg^4-480*xarg^2)*loc[i1-2]-(1440*xarg^5-384*I*xarg^4)*loc[i1-1]-(63699*xarg^2-1348+240*I*a1^2*xarg-17340*I*xarg-1356*a1^2*xarg^2+16*a1^2)*loc[i1-4]-((160*a1^2-9196)*loc[i1-6]+(-50140*xarg^3+13136*I*xarg^2-32*I*a1^2*xarg^2+400*a1^2*xarg^3+1056*xarg-32*I)*loc[i1-3]+(5456*I*xarg^3+400*xarg^2-19760*xarg^4+80*a1^2*xarg^4)*loc[i1-2]+(-3216*xarg^5+704*I*xarg^4)*loc[i1-1]+(4336*I+560*xarg*a1^2-38276*xarg-32*I*a1^2)*loc[i1-5]+(-62580*xarg^2+720*a1^2*xarg^2+12720*I*xarg+656-64*I*a1^2*xarg)*loc[i1-4]+((-160*xarg+22016*xarg^3-64*a1^2*xarg^3-3888*I*xarg^2)*loc[i1-3]+(-16*a1^2*xarg^4-2064*I*xarg^3+10864*xarg^4-80*xarg^2)*loc[i1-2]+(-384*I*xarg^4+2496*xarg^5)*loc[i1-1]+(2640-16*a1^2)*loc[i1-6]+(12352*xarg-64*xarg*a1^2-912*I)*loc[i1-5]+(23184*xarg^2-96*a1^2*xarg^2-80-3120*I*xarg)*loc[i1-4]+((-4320*xarg^3+384*I*xarg^2)*loc[i1-3]+(-2640*xarg^4+256*I*xarg^3)*loc[i1-2]-336*loc[i1-6]+(-1776*xarg+64*I)*loc[i1-5]+(-3840*xarg^2+256*I*xarg)*loc[i1-4]+(64*I*xarg^4-816*xarg^5)*loc[i1-1]+(320*xarg^3*loc[i1-3]+16*loc[i1-6]+96*xarg*loc[i1-5]+240*xarg^2*loc[i1-4]+240*xarg^4*loc[i1-2]+96*xarg^5*loc[i1-1])*i1)*i1)*i1)*i1)/(-96*xarg^6+(176*xarg^6+(-96*xarg^6+16*xarg^6*i1)*i1)*i1)/i1 end do; [seq(loc[i1],i1 = 0 .. n)] end if end proc:
`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`, 0, _a1::LinearProp(2,integer,1)]:=proc (expr, scale, var, order, a1) local d1, loc1, loc2, res, res1; option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:34`; ASSERT(`multiseries/limit`(expr,scale,var) = 0 or Testzero(`multiseries/limit`(expr,scale,var))); loc1 := `multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`,0,_a1::LinearProp(2,integer,1),"BasisVector",0,1,0,"MultiSeries"](expr,scale,var,order,a1); loc2 := limit(-d1/Pi,d1 = a1,'left'); if nops(loc1) = 1 then loc1 := [subsop(9 = 1/loc2*`WeberE/infinity/aux/0/-Pi .. Pi`(a1,eval(scale['variable'],1)),op(1,loc1))] end if; res1 := `multiseries/function`["Helper","RegularBasisVector"](loc1,[expr, scale, var, order],1,loc2,0); res := res1; subsop(9 = `WeberE/infinity/aux/0/-Pi .. Pi`(a1,op(9,expr)),res) end proc:
`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`, 0, "Generic", "BasisVector", 0, "MultiSeries"]:=proc (expr, scale, var, order, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:36`; [`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`,0,"Generic","BasisVector",0,"MultiSeries",0](args)] end proc:
`multiseries/function`[WeberE, 0, "BasisVector", 0, 0, 0]:=proc (n, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:23`; [0, `multiseries/function`[WeberE,0,"CoeffProc",1,1,1](n,a1), `multiseries/function`[WeberE,0,"CoeffProc",1,1,0](n,a1)] end proc:
`multiseries/function`[`WeberE/infinity/aux/2/-Pi .. Pi`]:=proc (exprlist, scale, var, order) local paramseq, expr, lim, lim2, argseq, res; option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:44`; if nops(exprlist) <> 2 then error "wrong number of arguments" end if; paramseq := op(map(`multiseries/Series2Expr`,[op(1 .. -2,exprlist)])); if has([paramseq],eval(scale['varname'],1)) then error "unable to expand with respect to parameter" end if; expr := op(-1,exprlist); if expr = 0 then return `multiseries/Convert2SERIES`(`WeberE/infinity/aux/2/-Pi .. Pi`(paramseq,0),scale,var,false) end if; lim := `multiseries/limit`(expr,scale,var); if lim = infinity then argseq := `multiseries/pow`(expr,-1,scale,var,order), scale, var, order, paramseq else argseq := `multiseries/AddDoit`(expr,`multiseries/Convert2SERIES`(-lim,scale,var,false)), scale, var, order, paramseq end if; if lim = 0 then res := `multiseries/function`[`WeberE/infinity/aux/2/-Pi .. Pi`,0](argseq) elif member(lim,{infinity}) then error "unable to compute series" else res := eval(`multiseries/function`[`WeberE/infinity/aux/2/-Pi .. Pi`,_AnyFiniteOrdinaryPoint](argseq),_AnyFiniteOrdinaryPoint = lim) end if; subsop(9 = `WeberE/infinity/aux/2/-Pi .. Pi`(paramseq,op(9,expr)),res) end proc:
`multiseries/function`[`WeberE/infinity/aux/2/-Pi .. Pi`, 0, "CoeffProc", 0]:=proc (n, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:42`; `multiseries/function`[`WeberE/infinity/aux/2/-Pi .. Pi`,0,"CoeffProc"](n,0,a1) end proc:
`multiseries/function`[`WeberE/infinity/aux/1/-Pi .. Pi`, _AnyFiniteOrdinaryPoint]:=proc (expr, scale, var, order, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:38`; `multiseries/compose`(SERIES(scale,map(normal,`multiseries/function`[`WeberE/infinity/aux/1/-Pi .. Pi`,_AnyFiniteOrdinaryPoint,"CoeffProc"](order,`WeberE/infinity/aux/1/-Pi .. Pi`(a1,_AnyFiniteOrdinaryPoint),D[2](`WeberE/infinity/aux/1/-Pi .. Pi`)(a1,_AnyFiniteOrdinaryPoint),2*D[2,2](`WeberE/infinity/aux/1/-Pi .. Pi`)(a1,_AnyFiniteOrdinaryPoint),6*D[2,2,2](`WeberE/infinity/aux/1/-Pi .. Pi`)(a1,_AnyFiniteOrdinaryPoint),a1,_AnyFiniteOrdinaryPoint)),1,algebraic,[`$`(0 .. order)],order+1,integer,eval(scale['variable'],1),`WeberE/infinity/aux/1/-Pi .. Pi`(a1,_AnyFiniteOrdinaryPoint+eval(scale['variable'],1))),expr,scale,var,order) end proc:
`multiseries/function`[WeberE, 0, "BasisVector", 0, 1, 0]:=proc (n, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:23`; [1, `multiseries/function`[WeberE,0,"CoeffProc",1,0,0](n,a1)] end proc:
`multiseries/function`[WeberE, 0]:=proc (expr, scale, var, order, a1) local d1, loc1, loc2, res, res1, res2; option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:29`; ASSERT(`multiseries/limit`(expr,scale,var) = 0 or Testzero(`multiseries/limit`(expr,scale,var))); loc1 := `multiseries/function`[WeberE,0,"BasisVector",0,0,0,"MultiSeries"](expr,scale,var,order,a1); loc2 := limit(-sin(1/2*d1*Pi)/GAMMA(1-1/2*d1)/GAMMA(1+1/2*d1)/(d1^2-1),d1 = a1,'left'); res1 := `multiseries/function`["Helper","RegularBasisVector"](loc1,[expr, scale, var, order],0,loc2,0); loc1 := `multiseries/function`[WeberE,0,"BasisVector",0,1,0,"MultiSeries"](expr,scale,var,order,a1); loc2 := limit(-1/4*cos(1/2*d1*Pi)/GAMMA(3/2-1/2*d1)/GAMMA(3/2+1/2*d1)/(d1^2-4),d1 = a1,'left'); res2 := `multiseries/function`["Helper","RegularBasisVector"](loc1,[expr, scale, var, order],1,loc2,0); res := `multiseries/add`([res1, res2]); subsop(9 = WeberE(a1,op(9,expr)),res) end proc:
`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`, 0, _a1::LinearProp(2,integer,1), "BasisVector", 0, 0, 0, "MultiSeries", 0]:=proc (expr, scale, var, order, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:32`; SERIES(scale,`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`,0,_a1::LinearProp(2,integer,1),"CoeffProc",1,1,1](order,a1),1,algebraic,[`$`(0 .. order)],order+1,integer,eval(scale['variable'],1),`WeberE/infinity/aux/0/-Pi .. Pi/0/_a1::LinearProp(2,integer,1)/BasisVector/0/0/0/MultiSeries/0`(a1,eval(scale['variable'],1))) end proc:
`multiseries/function`[WeberE, 0, "CoeffProc", -_a1, 0, 0]:=proc (n, a1) local i1, loc; option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:25`; if n = 0 then [1] elif n = 1 then [1, 0] elif n = 2 then [1, 0, 1/4/(a1-1)] else loc[0] := 1; loc[1] := 0; loc[2] := 1/4/(a1-1); for i1 from 3 to n do loc[i1] := normal(-loc[i1-2]/(-2*a1+i1)/i1) end do; [seq(loc[i1],i1 = 0 .. n)] end if end proc:
`multiseries/function`[WeberE, 0, "CoeffProc", 1, 0, 0]:=proc (n, a1) local i1, loc; option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:22`; if n = 0 then [-2*a1^2+8] elif n = 1 then [-2*a1^2+8, 0] elif n = 2 then [-2*a1^2+8, 0, -2*(a1^2-4)/(-9+a1^2)] else loc[0] := -2*a1^2+8; loc[1] := 0; loc[2] := -2*(a1^2-4)/(-9+a1^2); for i1 from 3 to n do loc[i1] := normal(-loc[i1-2]/(-a1^2+1+(i1+2)*i1)) end do; [seq(loc[i1],i1 = 0 .. n)] end if end proc:
`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`, 0, _a1::LinearProp(2,integer,1), "BasisVector", 0, 1, 0, "MultiSeries", 0]:=proc (expr, scale, var, order, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:33`; SERIES(scale,`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`,0,_a1::LinearProp(2,integer,1),"CoeffProc",1,0,0](order,a1),1,algebraic,[`$`(0 .. order)],order+1,integer,eval(scale['variable'],1),`WeberE/infinity/aux/0/-Pi .. Pi/0/_a1::LinearProp(2,integer,1)/BasisVector/0/1/0/MultiSeries/0`(a1,eval(scale['variable'],1))) end proc:
`multiseries/function`[WeberE, 0, "BasisVector", 0, 0, 0, "MultiSeries", 0]:=proc (expr, scale, var, order, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:26`; SERIES(scale,`multiseries/function`[WeberE,0,"CoeffProc",1,1,1](order,a1),1,algebraic,[`$`(0 .. order)],order+1,integer,eval(scale['variable'],1),`WeberE/0/BasisVector/0/0/0/MultiSeries/0`(a1,eval(scale['variable'],1))) end proc:
`multiseries/function`[WeberE, 0, "BasisVector", 0, 0, 0, "MultiSeries", 1]:=proc (expr, scale, var, order, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:26`; SERIES(scale,`multiseries/function`[WeberE,0,"CoeffProc",1,1,0](order,a1),1,algebraic,[`$`(0 .. order)],order+1,integer,eval(scale['variable'],1),`WeberE/0/BasisVector/0/0/0/MultiSeries/1`(a1,eval(scale['variable'],1))) end proc:
`multiseries/function`[WeberE, 0, "CoeffProc", _a1, 0, 0]:=proc (n, a1) local i1, loc; option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:24`; if n = 0 then [1] elif n = 1 then [1, 0] elif n = 2 then [1, 0, -1/4/(a1+1)] else loc[0] := 1; loc[1] := 0; loc[2] := -1/4/(a1+1); for i1 from 3 to n do loc[i1] := normal(-loc[i1-2]/(2*a1+i1)/i1) end do; [seq(loc[i1],i1 = 0 .. n)] end if end proc:
`multiseries/function`[WeberE, _AnyFiniteOrdinaryPoint]:=proc (expr, scale, var, order, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:21`; `multiseries/compose`(SERIES(scale,map(normal,`multiseries/function`[WeberE,_AnyFiniteOrdinaryPoint,"CoeffProc"](order,WeberE(a1,_AnyFiniteOrdinaryPoint),-WeberE(a1+1,_AnyFiniteOrdinaryPoint)+a1/_AnyFiniteOrdinaryPoint*WeberE(a1,_AnyFiniteOrdinaryPoint)-(1-cos(a1*Pi))/Pi/_AnyFiniteOrdinaryPoint,-2*WeberE(a1,_AnyFiniteOrdinaryPoint)+2*(a1+1)/_AnyFiniteOrdinaryPoint*WeberE(a1+1,_AnyFiniteOrdinaryPoint)-2*(1-cos((a1+1)*Pi))/Pi/_AnyFiniteOrdinaryPoint-2*a1/_AnyFiniteOrdinaryPoint^2*WeberE(a1,_AnyFiniteOrdinaryPoint)+2*a1/_AnyFiniteOrdinaryPoint*(-WeberE(a1+1,_AnyFiniteOrdinaryPoint)+a1/_AnyFiniteOrdinaryPoint*WeberE(a1,_AnyFiniteOrdinaryPoint)-(1-cos(a1*Pi))/Pi/_AnyFiniteOrdinaryPoint)+2*(1-cos(a1*Pi))/Pi/_AnyFiniteOrdinaryPoint^2,6*WeberE(a1+1,_AnyFiniteOrdinaryPoint)-6*a1/_AnyFiniteOrdinaryPoint*WeberE(a1,_AnyFiniteOrdinaryPoint)+6*(1-cos(a1*Pi))/Pi/_AnyFiniteOrdinaryPoint-6*(a1+1)/_AnyFiniteOrdinaryPoint^2*WeberE(a1+1,_AnyFiniteOrdinaryPoint)+6*(a1+1)/_AnyFiniteOrdinaryPoint*(WeberE(a1,_AnyFiniteOrdinaryPoint)-(a1+1)/_AnyFiniteOrdinaryPoint*WeberE(a1+1,_AnyFiniteOrdinaryPoint)+(1-cos((a1+1)*Pi))/Pi/_AnyFiniteOrdinaryPoint)+6*(1-cos((a1+1)*Pi))/Pi/_AnyFiniteOrdinaryPoint^2+12*a1/_AnyFiniteOrdinaryPoint^3*WeberE(a1,_AnyFiniteOrdinaryPoint)-12*a1/_AnyFiniteOrdinaryPoint^2*(-WeberE(a1+1,_AnyFiniteOrdinaryPoint)+a1/_AnyFiniteOrdinaryPoint*WeberE(a1,_AnyFiniteOrdinaryPoint)-(1-cos(a1*Pi))/Pi/_AnyFiniteOrdinaryPoint)+6*a1/_AnyFiniteOrdinaryPoint*(-WeberE(a1,_AnyFiniteOrdinaryPoint)+(a1+1)/_AnyFiniteOrdinaryPoint*WeberE(a1+1,_AnyFiniteOrdinaryPoint)-(1-cos((a1+1)*Pi))/Pi/_AnyFiniteOrdinaryPoint-a1/_AnyFiniteOrdinaryPoint^2*WeberE(a1,_AnyFiniteOrdinaryPoint)+a1/_AnyFiniteOrdinaryPoint*(-WeberE(a1+1,_AnyFiniteOrdinaryPoint)+a1/_AnyFiniteOrdinaryPoint*WeberE(a1,_AnyFiniteOrdinaryPoint)-(1-cos(a1*Pi))/Pi/_AnyFiniteOrdinaryPoint)+(1-cos(a1*Pi))/Pi/_AnyFiniteOrdinaryPoint^2)-12*(1-cos(a1*Pi))/Pi/_AnyFiniteOrdinaryPoint^3,a1,_AnyFiniteOrdinaryPoint)),1,algebraic,[`$`(0 .. order)],order+1,integer,eval(scale['variable'],1),WeberE(a1,_AnyFiniteOrdinaryPoint+eval(scale['variable'],1))),expr,scale,var,order) end proc:
`multiseries/function`[WeberE, 0, "BasisVector", _a1, 0, 0, "MultiSeries", 0]:=proc (expr, scale, var, order, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:28`; SERIES(scale,`multiseries/function`[WeberE,0,"CoeffProc",_a1,0,0](order,a1),1,algebraic,[`$`(0 .. order)],order+1,integer,eval(scale['variable'],1),`WeberE/0/BasisVector/_a1/0/0/MultiSeries/0`(a1,eval(scale['variable'],1))) end proc:
`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`, 0, _a1::LinearProp(2,integer,1), "CoeffProc", 1, 0, 0]:=proc (n, a1) local i1, loc; option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:31`; if n = 0 then [2] elif n = 1 then [2, 0] elif n = 2 then [2, 0, -8+2*a1^2] else loc[0] := 2; loc[1] := 0; loc[2] := -8+2*a1^2; for i1 from 3 to n do loc[i1] := normal(-(-a1^2+i1^2)*loc[i1-2]) end do; [seq(loc[i1],i1 = 0 .. n)] end if end proc:
`multiseries/function`[WeberE, 0, "BasisVector", -_a1, 0, 0]:=proc (n, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:26`; [-a1, `multiseries/function`[WeberE,0,"CoeffProc",-_a1,0,0](n,a1)] end proc:
`multiseries/function`[WeberE, 0, "BasisVector", -_a1, 0, 0, "MultiSeries"]:=proc (expr, scale, var, order, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:28`; [`multiseries/function`[WeberE,0,"BasisVector",-_a1,0,0,"MultiSeries",0](args)] end proc:
`multiseries/function`[`WeberE/infinity/aux/1/-Pi .. Pi`, 0]:=proc (expr, scale, var, order, a1) local d1, loc1, loc2, res, res1; option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:40`; ASSERT(`multiseries/limit`(expr,scale,var) = 0 or Testzero(`multiseries/limit`(expr,scale,var))); loc1 := `multiseries/function`[`WeberE/infinity/aux/1/-Pi .. Pi`,0,"BasisVector",0,"MultiSeries"](expr,scale,var,order,a1); loc2 := limit(-1/2*I*2^(1/2)/Pi^(1/2)*exp(1/4*I*Pi*(2*d1+1)),d1 = a1,'left'); if nops(loc1) = 1 then loc1 := [subsop(9 = 1/loc2*`WeberE/infinity/aux/1/-Pi .. Pi`(a1,eval(scale['variable'],1)),op(1,loc1))] end if; res1 := `multiseries/function`["Helper","RegularBasisVector"](loc1,[expr, scale, var, order],0,loc2,0); res := res1; subsop(9 = `WeberE/infinity/aux/1/-Pi .. Pi`(a1,op(9,expr)),res) end proc:
`multiseries/function`[WeberE, infinity, -Pi .. Pi]:=proc (expr, scale, var, order, a1, arglist) local res; option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:44`; res := `multiseries/add`([`multiseries/mul`([expr, `multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`](op(arglist))]), `multiseries/mul`([`multiseries/pow`(expr,1/2,scale,var,order), `multiseries/function`[exp](`multiseries/MulDoit`(`multiseries/pow`(expr,-1,scale,var,order),-I),scale,var,order), `multiseries/function`[`WeberE/infinity/aux/1/-Pi .. Pi`](op(arglist))]), `multiseries/mul`([`multiseries/pow`(expr,1/2,scale,var,order), `multiseries/function`[exp](`multiseries/MulDoit`(`multiseries/pow`(expr,-1,scale,var,order),I),scale,var,order), `multiseries/function`[`WeberE/infinity/aux/2/-Pi .. Pi`](op(arglist))])]) end proc:
`multiseries/function`[`WeberE/infinity/aux/2/-Pi .. Pi`, _AnyFiniteOrdinaryPoint]:=proc (expr, scale, var, order, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:41`; `multiseries/compose`(SERIES(scale,map(normal,`multiseries/function`[`WeberE/infinity/aux/2/-Pi .. Pi`,_AnyFiniteOrdinaryPoint,"CoeffProc"](order,`WeberE/infinity/aux/2/-Pi .. Pi`(a1,_AnyFiniteOrdinaryPoint),D[2](`WeberE/infinity/aux/2/-Pi .. Pi`)(a1,_AnyFiniteOrdinaryPoint),2*D[2,2](`WeberE/infinity/aux/2/-Pi .. Pi`)(a1,_AnyFiniteOrdinaryPoint),6*D[2,2,2](`WeberE/infinity/aux/2/-Pi .. Pi`)(a1,_AnyFiniteOrdinaryPoint),a1,_AnyFiniteOrdinaryPoint)),1,algebraic,[`$`(0 .. order)],order+1,integer,eval(scale['variable'],1),`WeberE/infinity/aux/2/-Pi .. Pi`(a1,_AnyFiniteOrdinaryPoint+eval(scale['variable'],1))),expr,scale,var,order) end proc:
`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`, 0, _a1::LinearProp(2,integer,1), "BasisVector", 0, 1, 0, "MultiSeries"]:=proc (expr, scale, var, order, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:34`; [`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`,0,_a1::LinearProp(2,integer,1),"BasisVector",0,1,0,"MultiSeries",0](args)] end proc:
`multiseries/function`[`WeberE/infinity/aux/2/-Pi .. Pi`, _AnyFiniteOrdinaryPoint, "CoeffProc"]:=proc (n, arg0, arg1, arg2, arg3, a1, xarg) local i1, loc; option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:41`; if n = 0 then [arg0] elif n = 1 then [arg0, arg1] elif n = 2 then [arg0, arg1, 1/4*arg2] elif n = 3 then [arg0, arg1, 1/4*arg2, 1/36*arg3] elif n = 4 then [arg0, arg1, 1/4*arg2, 1/36*arg3, 1/1152/xarg^6*(12*arg0+360*I*arg2*xarg^3+36*arg0*a1^2*xarg^2-9*arg0*xarg^2+32*I*arg3*xarg^4-48*arg0*a1^2+144*arg1*a1^2*xarg^3+12*I*arg0*xarg-396*arg1*xarg^3-96*I*arg1-96*I*arg1*a1^2*xarg^2+192*arg1*xarg+120*arg2*xarg^2-48*I*arg0*a1^2*xarg+24*arg2*a1^2*xarg^4-456*arg2*xarg^4+384*I*arg1*xarg^2-72*arg3*xarg^5)] elif n = 5 then [arg0, arg1, 1/4*arg2, 1/36*arg3, 1/1152/xarg^6*(12*arg0+360*I*arg2*xarg^3+36*arg0*a1^2*xarg^2-9*arg0*xarg^2+32*I*arg3*xarg^4-48*arg0*a1^2+144*arg1*a1^2*xarg^3+12*I*arg0*xarg-396*arg1*xarg^3-96*I*arg1-96*I*arg1*a1^2*xarg^2+192*arg1*xarg+120*arg2*xarg^2-48*I*arg0*a1^2*xarg+24*arg2*a1^2*xarg^4-456*arg2*xarg^4+384*I*arg1*xarg^2-72*arg3*xarg^5), -1/5760/xarg^8*(-912*arg0*a1^2*xarg-432*I*arg2*xarg^2-384*arg1-2208*I*arg1*xarg-336*arg1*a1^2*xarg^2+192*arg2*a1^2*xarg^5+520*I*arg3*xarg^5+5952*I*arg2*xarg^4+1692*arg1*a1^2*xarg^4+204*I*arg0*xarg^2-8*arg3*a1^2*xarg^6-48*I*arg2*a1^2*xarg^4+6564*I*arg1*xarg^3+192*I*arg0*a1^2-48*I*arg0+468*arg0*a1^2*xarg^3+228*arg0*xarg+4212*arg1*xarg^2+2904*arg2*xarg^3-4818*arg2*xarg^5-4743*arg1*xarg^4-117*arg0*xarg^3-568*arg3*xarg^6+88*arg3*xarg^4-816*I*arg0*a1^2*xarg^2-1776*I*arg1*a1^2*xarg^3)] else loc[0] := arg0; loc[1] := arg1; loc[2] := 1/4*arg2; loc[3] := 1/36*arg3; loc[4] := 1/1152/xarg^6*(12*arg0+360*I*arg2*xarg^3+36*arg0*a1^2*xarg^2-9*arg0*xarg^2+32*I*arg3*xarg^4-48*arg0*a1^2+144*arg1*a1^2*xarg^3+12*I*arg0*xarg-396*arg1*xarg^3-96*I*arg1-96*I*arg1*a1^2*xarg^2+192*arg1*xarg+120*arg2*xarg^2-48*I*arg0*a1^2*xarg+24*arg2*a1^2*xarg^4-456*arg2*xarg^4+384*I*arg1*xarg^2-72*arg3*xarg^5); loc[5] := -1/5760/xarg^8*(-912*arg0*a1^2*xarg-432*I*arg2*xarg^2-384*arg1-2208*I*arg1*xarg-336*arg1*a1^2*xarg^2+192*arg2*a1^2*xarg^5+520*I*arg3*xarg^5+5952*I*arg2*xarg^4+1692*arg1*a1^2*xarg^4+204*I*arg0*xarg^2-8*arg3*a1^2*xarg^6-48*I*arg2*a1^2*xarg^4+6564*I*arg1*xarg^3+192*I*arg0*a1^2-48*I*arg0+468*arg0*a1^2*xarg^3+228*arg0*xarg+4212*arg1*xarg^2+2904*arg2*xarg^3-4818*arg2*xarg^5-4743*arg1*xarg^4-117*arg0*xarg^3-568*arg3*xarg^6+88*arg3*xarg^4-816*I*arg0*a1^2*xarg^2-1776*I*arg1*a1^2*xarg^3); for i1 from 6 to n do loc[i1] := (-(11979-396*a1^2)*loc[i1-6]-(44586*xarg+6876*I-1224*xarg*a1^2-144*I*a1^2)*loc[i1-5]-(42996*xarg^3-96*I-96*I*a1^2*xarg^2-1728*xarg+14784*I*xarg^2-624*a1^2*xarg^3)*loc[i1-3]-(13344*xarg^4-96*a1^2*xarg^4+4704*I*xarg^3-480*xarg^2)*loc[i1-2]-(1440*xarg^5+384*I*xarg^4)*loc[i1-1]-(63699*xarg^2-1356*a1^2*xarg^2-1348+17340*I*xarg+16*a1^2-240*I*a1^2*xarg)*loc[i1-4]-((160*a1^2-9196)*loc[i1-6]+(1056*xarg-50140*xarg^3+32*I*a1^2*xarg^2+400*a1^2*xarg^3-13136*I*xarg^2+32*I)*loc[i1-3]+(-5456*I*xarg^3+80*a1^2*xarg^4-19760*xarg^4+400*xarg^2)*loc[i1-2]+(-704*I*xarg^4-3216*xarg^5)*loc[i1-1]+(-4336*I-38276*xarg+560*xarg*a1^2+32*I*a1^2)*loc[i1-5]+(-62580*xarg^2+720*a1^2*xarg^2-12720*I*xarg+656+64*I*a1^2*xarg)*loc[i1-4]+((22016*xarg^3+3888*I*xarg^2-64*a1^2*xarg^3-160*xarg)*loc[i1-3]+(2064*I*xarg^3+10864*xarg^4-16*a1^2*xarg^4-80*xarg^2)*loc[i1-2]+(2496*xarg^5+384*I*xarg^4)*loc[i1-1]+(2640-16*a1^2)*loc[i1-6]+(912*I+12352*xarg-64*xarg*a1^2)*loc[i1-5]+(-96*a1^2*xarg^2+23184*xarg^2+3120*I*xarg-80)*loc[i1-4]+((-4320*xarg^3-384*I*xarg^2)*loc[i1-3]+(-2640*xarg^4-256*I*xarg^3)*loc[i1-2]-336*loc[i1-6]+(-64*I-1776*xarg)*loc[i1-5]+(-3840*xarg^2-256*I*xarg)*loc[i1-4]+(-816*xarg^5-64*I*xarg^4)*loc[i1-1]+(320*xarg^3*loc[i1-3]+16*loc[i1-6]+96*xarg*loc[i1-5]+240*xarg^2*loc[i1-4]+240*xarg^4*loc[i1-2]+96*xarg^5*loc[i1-1])*i1)*i1)*i1)*i1)/(-96*xarg^6+(176*xarg^6+(-96*xarg^6+16*xarg^6*i1)*i1)*i1)/i1 end do; [seq(loc[i1],i1 = 0 .. n)] end if end proc:
`multiseries/function`[`WeberE/infinity/aux/2/-Pi .. Pi`, 0, "BasisVector", 0, "MultiSeries"]:=proc (expr, scale, var, order, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:43`; [`multiseries/function`[`WeberE/infinity/aux/2/-Pi .. Pi`,0,"BasisVector",0,"MultiSeries",0](args)] end proc:
`multiseries/function`[WeberE, 0, "CoeffProc", 1, 1, 1]:=proc (n, a1) local i1, loc; option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:23`; if n = 0 then [1-a1^2] elif n = 1 then [1-a1^2, 0] elif n = 2 then [1-a1^2, 0, -(a1^2-1)/(a1^2-4)] elif n = 3 then [1-a1^2, 0, -(a1^2-1)/(a1^2-4), 0] else loc[0] := 1-a1^2; loc[1] := 0; loc[2] := -(a1^2-1)/(a1^2-4); loc[3] := 0; for i1 from 4 to n do loc[i1] := normal(-loc[i1-2]/(-a1^2+i1^2)) end do; [seq(loc[i1],i1 = 0 .. n)] end if end proc:
`multiseries/function`[`WeberE/infinity/aux/1/-Pi .. Pi`, 0, "BasisVector", 0, "MultiSeries", 0]:=proc (expr, scale, var, order, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:39`; SERIES(scale,`multiseries/function`[`WeberE/infinity/aux/1/-Pi .. Pi`,0,"CoeffProc",0](order,a1),1,algebraic,[`$`(0 .. order)],order+1,integer,eval(scale['variable'],1),`WeberE/infinity/aux/1/-Pi .. Pi/0/BasisVector/0/MultiSeries/0`(a1,eval(scale['variable'],1))) end proc:
`multiseries/function`[`WeberE/infinity/aux/1/-Pi .. Pi`, 0, "CoeffProc"]:=proc (n, c, a1) local i1, loc; option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:38`; if n = 0 then [normal(1)] elif n = 1 then [normal(1), normal(-1/8*I*(-1+4*a1^2+4*c-20*c^2)/(c+1))] elif n = 2 then [normal(1), normal(-1/8*I*(-1+4*a1^2+4*c-20*c^2)/(c+1)), normal(-1/64/(c^2+3*c+2)*(272*c^4+416*c^3-32*c*a1^2-40*a1^2+88*c^2-96*c^2*a1^2-72*c+9+16*a1^4))] else loc[0] := normal(1); loc[1] := normal(-1/8*I*(-1+4*a1^2+4*c-20*c^2)/(c+1)); loc[2] := normal(-1/64/(c^2+3*c+2)*(272*c^4+416*c^3-32*c*a1^2-40*a1^2+88*c^2-96*c^2*a1^2-72*c+9+16*a1^4)); for i1 from 3 to n do loc[i1] := normal((-(375-700*c-60*a1^2+64*c*a1^2-144*c^3+480*c^2+16*c^4-16*c^2*a1^2)*loc[i1-3]-(64*I*c^3-336*I*c^2-348*I+592*I*c-32*I*a1^2*c+48*I*a1^2)*loc[i1-2]-(-100+16*a1^2+176*c-80*c^2)*loc[i1-1]-((592*I-672*I*c+192*I*c^2-32*I*a1^2)*loc[i1-2]+(-160*c+176)*loc[i1-1]+(960*c+64*a1^2-432*c^2-700+64*c^3-32*c*a1^2)*loc[i1-3]+((-336*I+192*I*c)*loc[i1-2]-80*loc[i1-1]+(-432*c+96*c^2-16*a1^2+480)*loc[i1-3]+(64*I*loc[i1-2]+(64*c-144)*loc[i1-3]+16*loc[i1-3]*i1)*i1)*i1)*i1)/(-32*I*c-32*I*i1)) end do; [seq(loc[i1],i1 = 0 .. n)] end if end proc:
`multiseries/function`[`WeberE/infinity/aux/2/-Pi .. Pi`, 0, "CoeffProc"]:=proc (n, c, a1) local i1, loc; option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:42`; if n = 0 then [normal(1)] elif n = 1 then [normal(1), normal(1/8*I*(-1+4*a1^2+4*c-20*c^2)/(c+1))] elif n = 2 then [normal(1), normal(1/8*I*(-1+4*a1^2+4*c-20*c^2)/(c+1)), normal(-1/64/(c^2+3*c+2)*(272*c^4+416*c^3-32*c*a1^2-40*a1^2+88*c^2-96*c^2*a1^2-72*c+9+16*a1^4))] else loc[0] := normal(1); loc[1] := normal(1/8*I*(-1+4*a1^2+4*c-20*c^2)/(c+1)); loc[2] := normal(-1/64/(c^2+3*c+2)*(272*c^4+416*c^3-32*c*a1^2-40*a1^2+88*c^2-96*c^2*a1^2-72*c+9+16*a1^4)); for i1 from 3 to n do loc[i1] := normal((-(375-700*c-60*a1^2+64*c*a1^2-144*c^3+480*c^2+16*c^4-16*c^2*a1^2)*loc[i1-3]-(-64*I*c^3+336*I*c^2+348*I-592*I*c-48*I*a1^2+32*I*a1^2*c)*loc[i1-2]-(-100+16*a1^2+176*c-80*c^2)*loc[i1-1]-((672*I*c-192*I*c^2-592*I+32*I*a1^2)*loc[i1-2]+(-160*c+176)*loc[i1-1]+(960*c+64*a1^2-432*c^2-700+64*c^3-32*c*a1^2)*loc[i1-3]+((336*I-192*I*c)*loc[i1-2]-80*loc[i1-1]+(-432*c+96*c^2-16*a1^2+480)*loc[i1-3]+(-64*I*loc[i1-2]+(64*c-144)*loc[i1-3]+16*loc[i1-3]*i1)*i1)*i1)*i1)/(32*I*c+32*I*i1)) end do; [seq(loc[i1],i1 = 0 .. n)] end if end proc:
`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`, 0, "Generic", "CoeffProc", 0]:=proc (n, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:35`; `multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`,0,"Generic","CoeffProc"](n,0,a1) end proc:
`multiseries/function`[WeberE, 0, "BasisVector", -_a1, 0, 0, "MultiSeries", 0]:=proc (expr, scale, var, order, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:28`; SERIES(scale,`multiseries/function`[WeberE,0,"CoeffProc",-_a1,0,0](order,a1),1,algebraic,[`$`(0 .. order)],order+1,integer,eval(scale['variable'],1),`WeberE/0/BasisVector/-_a1/0/0/MultiSeries/0`(a1,eval(scale['variable'],1))) end proc:
`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`, 0, _a1::LinearProp(2,integer,1), "BasisVector", 0, 0, 0, "MultiSeries", 1]:=proc (expr, scale, var, order, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:33`; SERIES(scale,`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`,0,_a1::LinearProp(2,integer,1),"CoeffProc",1,1,0](order,a1),1,algebraic,[`$`(0 .. order)],order+1,integer,eval(scale['variable'],1),`WeberE/infinity/aux/0/-Pi .. Pi/0/_a1::LinearProp(2,integer,1)/BasisVector/0/0/0/MultiSeries/1`(a1,eval(scale['variable'],1))) end proc:
`multiseries/function`[`WeberE/infinity/aux/2/-Pi .. Pi`, 0]:=proc (expr, scale, var, order, a1) local d1, loc1, loc2, res, res1; option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:43`; ASSERT(`multiseries/limit`(expr,scale,var) = 0 or Testzero(`multiseries/limit`(expr,scale,var))); loc1 := `multiseries/function`[`WeberE/infinity/aux/2/-Pi .. Pi`,0,"BasisVector",0,"MultiSeries"](expr,scale,var,order,a1); loc2 := limit(1/2*I*2^(1/2)/Pi^(1/2)*exp(-1/4*I*Pi*(2*d1+1)),d1 = a1,'left'); if nops(loc1) = 1 then loc1 := [subsop(9 = 1/loc2*`WeberE/infinity/aux/2/-Pi .. Pi`(a1,eval(scale['variable'],1)),op(1,loc1))] end if; res1 := `multiseries/function`["Helper","RegularBasisVector"](loc1,[expr, scale, var, order],0,loc2,0); res := res1; subsop(9 = `WeberE/infinity/aux/2/-Pi .. Pi`(a1,op(9,expr)),res) end proc:
`multiseries/function`[WeberE, 0, "BasisVector", 0, 1, 0, "MultiSeries"]:=proc (expr, scale, var, order, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:27`; [`multiseries/function`[WeberE,0,"BasisVector",0,1,0,"MultiSeries",0](args)] end proc:
`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`, 0, "Generic", "BasisVector", 0]:=proc (n, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:35`; [0, `multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`,0,"Generic","CoeffProc"](n,0,a1)] end proc:
`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`]:=proc (exprlist, scale, var, order) local paramseq, expr, lim, lim2, argseq, res; option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:37`; if nops(exprlist) <> 2 then error "wrong number of arguments" end if; paramseq := op(map(`multiseries/Series2Expr`,[op(1 .. -2,exprlist)])); if has([paramseq],eval(scale['varname'],1)) then error "unable to expand with respect to parameter" end if; expr := op(-1,exprlist); if expr = 0 then return `multiseries/Convert2SERIES`(`WeberE/infinity/aux/0/-Pi .. Pi`(paramseq,0),scale,var,false) end if; lim := `multiseries/limit`(expr,scale,var); if lim = infinity then argseq := `multiseries/pow`(expr,-1,scale,var,order), scale, var, order, paramseq else argseq := `multiseries/AddDoit`(expr,`multiseries/Convert2SERIES`(-lim,scale,var,false)), scale, var, order, paramseq end if; if lim = 0 then res := `multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`,0](argseq) elif member(lim,{infinity}) then error "unable to compute series" else res := eval(`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`,_AnyFiniteOrdinaryPoint](argseq),_AnyFiniteOrdinaryPoint = lim) end if; subsop(9 = `WeberE/infinity/aux/0/-Pi .. Pi`(paramseq,op(9,expr)),res) end proc:
`multiseries/function`[`WeberE/infinity/aux/1/-Pi .. Pi`]:=proc (exprlist, scale, var, order) local paramseq, expr, lim, lim2, argseq, res; option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:40`; if nops(exprlist) <> 2 then error "wrong number of arguments" end if; paramseq := op(map(`multiseries/Series2Expr`,[op(1 .. -2,exprlist)])); if has([paramseq],eval(scale['varname'],1)) then error "unable to expand with respect to parameter" end if; expr := op(-1,exprlist); if expr = 0 then return `multiseries/Convert2SERIES`(`WeberE/infinity/aux/1/-Pi .. Pi`(paramseq,0),scale,var,false) end if; lim := `multiseries/limit`(expr,scale,var); if lim = infinity then argseq := `multiseries/pow`(expr,-1,scale,var,order), scale, var, order, paramseq else argseq := `multiseries/AddDoit`(expr,`multiseries/Convert2SERIES`(-lim,scale,var,false)), scale, var, order, paramseq end if; if lim = 0 then res := `multiseries/function`[`WeberE/infinity/aux/1/-Pi .. Pi`,0](argseq) elif member(lim,{infinity}) then error "unable to compute series" else res := eval(`multiseries/function`[`WeberE/infinity/aux/1/-Pi .. Pi`,_AnyFiniteOrdinaryPoint](argseq),_AnyFiniteOrdinaryPoint = lim) end if; subsop(9 = `WeberE/infinity/aux/1/-Pi .. Pi`(paramseq,op(9,expr)),res) end proc:
`multiseries/function`[WeberE, _AnyFiniteOrdinaryPoint, "CoeffProc"]:=proc (n, arg0, arg1, arg2, arg3, a1, xarg) local i1, loc; option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:21`; if n = 0 then [arg0] elif n = 1 then [arg0, arg1] elif n = 2 then [arg0, arg1, 1/4*arg2] elif n = 3 then [arg0, arg1, 1/4*arg2, 1/36*arg3] else loc[0] := arg0; loc[1] := arg1; loc[2] := 1/4*arg2; loc[3] := 1/36*arg3; for i1 from 4 to n do loc[i1] := (-loc[i1-4]-2*xarg*loc[i1-3]-(4+xarg^2-a1^2)*loc[i1-2]-3*xarg*loc[i1-1]-(-4*loc[i1-2]-5*xarg*loc[i1-1]+(loc[i1-2]+2*xarg*loc[i1-1])*i1)*i1)/(-xarg^2+xarg^2*i1)/i1 end do; [seq(loc[i1],i1 = 0 .. n)] end if end proc:
`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`, 0, _a1::LinearProp(2,integer,1), "BasisVector", 0, 0, 0, "MultiSeries"]:=proc (expr, scale, var, order, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:33`; [`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`,0,_a1::LinearProp(2,integer,1),"BasisVector",0,0,0,"MultiSeries",0](args), `multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`,0,_a1::LinearProp(2,integer,1),"BasisVector",0,0,0,"MultiSeries",1](args)] end proc:
`multiseries/function`[WeberE]:=proc (exprlist, scale, var, order) local paramseq, expr, lim, lim2, argseq, res; option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:44`; if nops(exprlist) <> 2 then error "wrong number of arguments" end if; paramseq := op(map(`multiseries/Series2Expr`,[op(1 .. -2,exprlist)])); if has([paramseq],eval(scale['varname'],1)) then error "unable to expand with respect to parameter" end if; expr := op(-1,exprlist); if expr = 0 then return `multiseries/Convert2SERIES`(WeberE(paramseq,0),scale,var,false) end if; lim := `multiseries/limit`(expr,scale,var); lim2 := lim; if lim = undefined then error "unable to compute series" elif has(lim,infinity) then lim := infinity end if; if lim = infinity then argseq := `multiseries/pow`(expr,-1,scale,var,order), scale, var, order, paramseq else argseq := `multiseries/AddDoit`(expr,`multiseries/Convert2SERIES`(-lim,scale,var,false)), scale, var, order, paramseq end if; if lim = 0 then res := `multiseries/function`[WeberE,0](argseq) elif lim = infinity then res := `multiseries/function`[WeberE,infinity,-Pi .. Pi](argseq,[[op(1 .. -2,exprlist), op(1,[argseq])], scale, var, order]) else res := eval(`multiseries/function`[WeberE,_AnyFiniteOrdinaryPoint](argseq),_AnyFiniteOrdinaryPoint = lim) end if; subsop(9 = WeberE(paramseq,op(9,expr)),res) end proc:
`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`, 0, _a1::LinearProp(2,integer,1), "BasisVector", 0, 0, 0]:=proc (n, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:32`; [0, `multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`,0,_a1::LinearProp(2,integer,1),"CoeffProc",1,1,1](n,a1), `multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`,0,_a1::LinearProp(2,integer,1),"CoeffProc",1,1,0](n,a1)] end proc:
`multiseries/function`[`WeberE/infinity/aux/1/-Pi .. Pi`, 0, "CoeffProc", 0]:=proc (n, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:39`; `multiseries/function`[`WeberE/infinity/aux/1/-Pi .. Pi`,0,"CoeffProc"](n,0,a1) end proc:
`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`, 0, _a1::LinearProp(2,integer,1), "BasisVector", 0, 1, 0]:=proc (n, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:32`; [1, `multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`,0,_a1::LinearProp(2,integer,1),"CoeffProc",1,0,0](n,a1)] end proc:
`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`, 0, "Generic"]:=proc (expr, scale, var, order, a1) local d1, loc1, loc2, res, res1; option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:36`; ASSERT(`multiseries/limit`(expr,scale,var) = 0 or Testzero(`multiseries/limit`(expr,scale,var))); loc1 := `multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`,0,"Generic","BasisVector",0,"MultiSeries"](expr,scale,var,order,a1); loc2 := limit(-(1+cos(d1*Pi))/Pi,d1 = a1,'left'); if nops(loc1) = 1 then loc1 := [subsop(9 = 1/loc2*`WeberE/infinity/aux/0/-Pi .. Pi`(a1,eval(scale['variable'],1)),op(1,loc1))] end if; res1 := `multiseries/function`["Helper","RegularBasisVector"](loc1,[expr, scale, var, order],0,loc2,0); res := res1; subsop(9 = `WeberE/infinity/aux/0/-Pi .. Pi`(a1,op(9,expr)),res) end proc:
`multiseries/function`[`WeberE/infinity/aux/1/-Pi .. Pi`, 0, "BasisVector", 0, "MultiSeries"]:=proc (expr, scale, var, order, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:39`; [`multiseries/function`[`WeberE/infinity/aux/1/-Pi .. Pi`,0,"BasisVector",0,"MultiSeries",0](args)] end proc:
`multiseries/function`[WeberE, 0, "CoeffProc", 1, 1, 0]:=proc (n, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:22`; [`$`(0,n+1)] end proc:
`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`, _AnyFiniteOrdinaryPoint]:=proc (expr, scale, var, order, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:30`; `multiseries/compose`(SERIES(scale,map(normal,`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`,_AnyFiniteOrdinaryPoint,"CoeffProc"](order,`WeberE/infinity/aux/0/-Pi .. Pi`(a1,_AnyFiniteOrdinaryPoint),D[2](`WeberE/infinity/aux/0/-Pi .. Pi`)(a1,_AnyFiniteOrdinaryPoint),2*D[2,2](`WeberE/infinity/aux/0/-Pi .. Pi`)(a1,_AnyFiniteOrdinaryPoint),6*D[2,2,2](`WeberE/infinity/aux/0/-Pi .. Pi`)(a1,_AnyFiniteOrdinaryPoint),a1,_AnyFiniteOrdinaryPoint)),1,algebraic,[`$`(0 .. order)],order+1,integer,eval(scale['variable'],1),`WeberE/infinity/aux/0/-Pi .. Pi`(a1,_AnyFiniteOrdinaryPoint+eval(scale['variable'],1))),expr,scale,var,order) end proc:
`multiseries/function`[`WeberE/infinity/aux/2/-Pi .. Pi`, 0, "BasisVector", 0]:=proc (n, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:42`; [0, `multiseries/function`[`WeberE/infinity/aux/2/-Pi .. Pi`,0,"CoeffProc"](n,0,a1)] end proc:
`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`, 0, _a1::LinearProp(2,integer,1), "CoeffProc", 1, 1, 0]:=proc (n, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:31`; [`$`(0,n+1)] end proc:
`multiseries/function`[WeberE, 0, "BasisVector", 0, 1, 0, "MultiSeries", 0]:=proc (expr, scale, var, order, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:27`; SERIES(scale,`multiseries/function`[WeberE,0,"CoeffProc",1,0,0](order,a1),1,algebraic,[`$`(0 .. order)],order+1,integer,eval(scale['variable'],1),`WeberE/0/BasisVector/0/1/0/MultiSeries/0`(a1,eval(scale['variable'],1))) end proc:
`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`, 0, "Generic", "CoeffProc"]:=proc (n, c, a1) local i1, loc; option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:34`; if n = 0 then [normal(1)] elif n = 1 then [normal(1), normal(0)] else loc[0] := normal(1); loc[1] := normal(0); for i1 from 2 to n do loc[i1] := normal(-(c^2-2*c+1-a1^2+(2*c-2+i1)*i1)*loc[i1-2]) end do; [seq(loc[i1],i1 = 0 .. n)] end if end proc:
`multiseries/function`[WeberE, 0, "BasisVector", _a1, 0, 0]:=proc (n, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:24`; [a1, `multiseries/function`[WeberE,0,"CoeffProc",_a1,0,0](n,a1)] end proc:
`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`, 0]:=proc (expr, scale, var, order, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:36`; if is(a1::LinearProp(2,integer,1)) then userinfo(2,`WeberE/infinity/aux/0/-Pi .. Pi`,`maincase:`,a1::LinearProp(2,integer,1)); `multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`,0,_a1::LinearProp(2,integer,1)](expr,scale,var,order,a1) else userinfo(2,`WeberE/infinity/aux/0/-Pi .. Pi`,`generic case`); `multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`,0,"Generic"](expr,scale,var,order,a1) end if end proc:
`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`, 0, "Generic", "BasisVector", 0, "MultiSeries", 0]:=proc (expr, scale, var, order, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:35`; SERIES(scale,`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`,0,"Generic","CoeffProc",0](order,a1),1,algebraic,[`$`(0 .. order)],order+1,integer,eval(scale['variable'],1),`WeberE/infinity/aux/0/-Pi .. Pi/0/Generic/BasisVector/0/MultiSeries/0`(a1,eval(scale['variable'],1))) end proc:
`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`, _AnyFiniteOrdinaryPoint, "CoeffProc"]:=proc (n, arg0, arg1, arg2, arg3, a1, xarg) local i1, loc; option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:29`; if n = 0 then [arg0] elif n = 1 then [arg0, arg1] elif n = 2 then [arg0, arg1, 1/4*arg2] elif n = 3 then [arg0, arg1, 1/4*arg2, 1/36*arg3] else loc[0] := arg0; loc[1] := arg1; loc[2] := 1/4*arg2; loc[3] := 1/36*arg3; for i1 from 4 to n do loc[i1] := (-(9-a1^2)*loc[i1-4]-5*xarg^3*loc[i1-1]-(1-a1^2*xarg^2+19*xarg^2)*loc[i1-2]-(23*xarg-2*xarg*a1^2)*loc[i1-3]-(-19*xarg*loc[i1-3]-6*loc[i1-4]-9*xarg^3*loc[i1-1]-21*xarg^2*loc[i1-2]+(6*xarg^2*loc[i1-2]+4*xarg*loc[i1-3]+loc[i1-4]+4*xarg^3*loc[i1-1])*i1)*i1)/(-xarg^4+xarg^4*i1)/i1 end do; [seq(loc[i1],i1 = 0 .. n)] end if end proc:
`multiseries/function`[WeberE, 0, "BasisVector", _a1, 0, 0, "MultiSeries"]:=proc (expr, scale, var, order, a1) option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:28`; [`multiseries/function`[WeberE,0,"BasisVector",_a1,0,0,"MultiSeries",0](args)] end proc:
`multiseries/function`[`WeberE/infinity/aux/0/-Pi .. Pi`, 0, _a1::LinearProp(2,integer,1), "CoeffProc", 1, 1, 1]:=proc (n, a1) local i1, loc; option `Copyright (c) 2004 by Ludovic Meunier and the Algorithms Project, INRIA. All rights reserved. - generated 10/26/2004 @ 23:21:31`; if n = 0 then [1] elif n = 1 then [1, 0] elif n = 2 then [1, 0, a1^2-1] elif n = 3 then [1, 0, a1^2-1, 0] else loc[0] := 1; loc[1] := 0; loc[2] := a1^2-1; loc[3] := 0; for i1 from 4 to n do loc[i1] := normal(-(1-a1^2+(i1-2)*i1)*loc[i1-2]) end do; [seq(loc[i1],i1 = 0 .. n)] end if end proc:
