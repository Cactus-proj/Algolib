# Copyright (C) 1991--2013 by INRIA.
#
# This file is part of Algolib.
#
# Algolib is free software: you can redistribute it and/or modify it
# under the terms of the GNU Lesser General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.
#
# Algolib is distributed in the hope that it will be useful, but
# WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
# Lesser General Public License for more details.
#
# You should have received a copy of the GNU Lesser General Public
# License along with Algolib.  If not, see
# <http://www.gnu.org/licenses/>.

# FUNCTIONALITY:
#        get lowest term in border that is not in a given monoideal
#
# INPUT:
#        border                a list of terms, sorted with respect to TOrd
#        monoideal        a list of terms generating a monoideal
#        TOrd                a term order
#
# OUTPUT:
#        t,new_border        where t is the lowest term in border that is
#                        not in the monoideal generated by monoideal
#                        and new_border has been updated in view of the
#                        FGLM algorithm
#
# ASSUMPTION:
#        border has to be sorted with respect to TOrd
#
# NOTE:
#        this is part of the FGLM algorithm
#
`Holonomy/next_term`:=proc(border,monoideal,TOrd)
    option `Copyright (c) 1995-2002 Frederic Chyzak, INRIA, France`;
    # border may not be the empty list.
    border[1],sort([op(2..-1,border),op(select(
        proc(t,b,m)
            option `Copyright (c) 1995-2002 Frederic Chyzak, INRIA, France`;
            (not member(t,b)) and (not has(map2(divide,t,m),true))
        end,
        map(proc(dx,ct)
            option `Copyright (c) 1995-2002 Frederic Chyzak, INRIA, France`;
            dx*ct
#        end,TOrd["algebra"]["right_indets"],border[1]),
        end,TOrd["order_indets"],border[1]),
        border,monoideal))],TOrd["order"])
end proc:

# FUNCTIONALITY:
#        FGLM algorithm
#
# INPUT:
#        normal_form        function that returns a normal form for terms
#                        in TOrd[algebra] (and stores it into NF); it
#                        will be used by calls of the form:
#
#                                normal_form(t,NF,TOrd)
#
#                        where t is a term, NF is a table with terms
#                        already dealt with as indices and normal forms
#                        already computed as corresponding entries and
#                        TOrd is a term order
#        find_dependency function that tries to find a dependency
#                        between expressions of the type returned by
#                        normal_form; it will be used by calls of the
#                        form:
#
#                                find_dependency(mi,NF)
#
#                        where mi is a list of terms that generate a
#                        monoideal and NF is a table of the same type
#                        as above.  This function should not use
#                        entries in NF corresponding to indices that
#                        are element of the monoideal described by mi;
#                        it has return either a non trivial linear
#                        combinaison of the indices of NF that
#                        evaluates to 0 under normal_form, or FAIL when
#                        no such dependency can be computed.
#
# OUTPUT:
#        NF,EQ        where NF is the table of all normal forms computed
#                during the calculations and EQ is a table of all
#                linear dependencies found
#
# WEAKNESS:
#        the algorithm cannot detect non-zero-dimensional cases, so
#        that it may loop for ever when called in such cases
#
# ALGORITHM:
#        extension of the FGLM algorithm to non-commutative settings
#        and more general normal forms
#
# REFERENCES:
#        ``Efficient Computation of Zero-dimensional Groebner Bases by
#        Change of Ordering'', by J.-C. Faugere, P. Gianni, D. Lazard
#        and T. Mora, Journal of Symbolic Computation (1993) 16,
#        329--344
#
`Holonomy/fglm_algorithm`:=proc(normal_form,find_dependency,
        termination_proc,TOrd)
    local current,border,monoideal,res,NF,EQ,ty,subs_list;
    option `Copyright (c) 1995-2009 Frederic Chyzak, INRIA, France`;
    global qdilat,FAIL;

    NF := table() ;
    EQ := table() ;

    # Accomodate some q-calculus cases.
    subs_list:=[seq(ty[4]^ty[3]=ty[2],
        ty=map2(op,2,select(has,TOrd["algebra"]["type_struct"],'qdilat')))];
    # Begin with the lowest term, namely 1.
    border:=[1];
    # Begin with no dependency found, and therefore with no term to be
    # avoided.
    monoideal:=[];
    while termination_proc(border,monoideal,TOrd) do
        userinfo(4,:-fglm,"border is ",border);
        userinfo(4,:-fglm,"monoideal to avoid is ",monoideal);
        res:=`Holonomy/next_term`(border,monoideal,TOrd);
        current:=res[1];
        userinfo(3,:-fglm,"deal with monomial ",current);
        border:=res[2];
        # The procedure normal_form stores the normal form of current
        # into the table NF.
        userinfo(4,:-fglm,"compute a normal form");
        normal_form(current,NF,TOrd);
        userinfo(5,:-fglm,"normal form for ",current," is ",NF[current]);
        userinfo(4,:-fglm,"find a dependency");
        res:=find_dependency(monoideal,NF);
        if res<>'FAIL' then
            EQ[current]:=subs(subs_list,res);
            monoideal:=[op(remove(divide,monoideal,current)),
                current];
            border:=remove(divide,border,current)
        end if
    end do;
    eval(NF),eval(EQ)
end proc:
